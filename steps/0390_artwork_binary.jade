//- If an <artwork> element has type=’binary-art’, the data needs to be in a
//- “src” attribute with a URI scheme of “data:”. If the “src” URI scheme is
//- “file:”, “http:”, or “https:”, resolve the URL. Replace the “src” attribute
//- with a “data:” URI, add an “originalSrc” attribute with the value of the
//- URI, and remove the “src” attribute. For the “http:” and “https:” URI
//- schemes, the mediatype of the “data:” URI will be the Content-Type of the
//- HTTP response. For the “file:” URI scheme, the mediatype of the “data:” URI
//- needs to be guessed with heuristics (this is possibly a bad idea). This also
//- fails for content that includes binary images but uses a type other than
//- “binary-art”. Note: since this feature can’t be used for RFCs at the moment,
//- this entire feature might be de-prioritized.

include ./elements.jade

mixin artwork(e)
  if $att(e, 'type') === 'binary-art'
    - var src = $att(e, 'src')
    if src
      - var suri = defs.url.parse(src)
      if (suri.protocol !== 'data:')
        - var buf = null
        - var media = null
        if suri.protocol === 'file:'
          - buf = defs.fs.readFileSync(suri.pathname)
          - media = defs.mime.lookup(suri.pathname)
        else if (suri.protocol === 'http:') || (suri.protocol === 'https:')
          - var res = defs.urllibsync.request(src)
          if res.status !== 200
            +error('HTTP error (' + res.statusCode + '): ' + src, e)
          - buf = res.data
          - media = res.headers['content-type'];
          - media = media.replace(/\s+/g, '');
        else
          +error('Unknown <artwork> src protocol: ' + suri.protocol, e)
        - e.attr('src', defs.dataUri.encode(buf, media))
        if !$att(e, 'originalSrc')
          - e.attr('originalSrc', src)
  +elem(e)

+root
